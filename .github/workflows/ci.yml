name: CI

on:
  pull_request:
    branches: [main]
  push:
    branches: [main]

jobs:
  # Job 1: Unit tests and code quality (no dependencies needed)
  unit-tests-and-lint:
    name: Unit Tests, Lint and Build
    runs-on: ubuntu-latest
    
    steps:
      # Checkout code
      - uses: actions/checkout@v4

      # Setup Go with caching
      - uses: actions/setup-go@v5
        with:
          go-version: '1.24'
          cache: true
          cache-dependency-path: go.sum

      # Download dependencies
      - name: Download dependencies
        run: go mod download

      # Code formatting check
      - name: Check formatting
        run: |
          if [ -n "$(gofmt -l .)" ]; then
            echo "Go code is not formatted:"
            gofmt -d .
            exit 1
          fi

      # Linting
      - name: Run go vet
        run: go vet ./...

      # Build verification
      - name: Build
        run: go build -v ./...

      # Unit tests (no database needed)
      - name: Run unit tests
        run: go test -v -race -coverprofile=coverage-unit.out ./tests/unit/...

      # Upload unit test coverage
      - name: Upload unit test coverage
        uses: actions/upload-artifact@v4
        with:
          name: coverage-unit
          path: coverage-unit.out

  # Job 2: Integration tests (needs application dependencies)
  integration-tests:
    name: Integration Tests
    runs-on: ubuntu-latest
    needs: unit-tests-and-lint  # Only run if unit tests pass
    
    # PostgreSQL service container
    services:
      postgres:
        image: postgres:16-alpine
        env:
          POSTGRES_USER: postgres
          POSTGRES_PASSWORD: postgres
          POSTGRES_DB: postgres
        ports:
          - 5432:5432
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
    
    steps:
      # Checkout code
      - uses: actions/checkout@v4

      # Setup Go with caching
      - uses: actions/setup-go@v5
        with:
          go-version: '1.24'
          cache: true
          cache-dependency-path: go.sum

      # Download dependencies
      - name: Download dependencies
        run: go mod download

      # Clone infrastructure repository for dependency provisioning
      - name: Clone infrastructure repository
        uses: actions/checkout@v4
        with:
          repository: gjaminon-go-labs/infrastructure
          path: infrastructure
          token: ${{ secrets.GITHUB_TOKEN }}

      # Provision all application dependencies
      - name: Provision application dependencies
        working-directory: infrastructure
        run: |
          # Setup CI environment configuration
          cp dependencies/database/config/.env.ci dependencies/database/config/.env.tst
          
          # Run generic provisioning script (handles all dependencies)
          chmod +x scripts/provision-dependencies.sh
          echo "y" | ./scripts/provision-dependencies.sh tst

      # Setup migration tool and run migrations
      - name: Setup and run database migrations
        run: |
          # Install golang-migrate
          curl -L https://github.com/golang-migrate/migrate/releases/download/v4.17.0/migrate.linux-amd64.tar.gz | tar xvz
          sudo mv migrate /usr/local/bin/
          migrate -version
          
          # Run migrations as migration user (provisioned by infrastructure)
          migrate -path database/migrations \
            -database "postgresql://billing_migration_tst_user:billing_migration_tst_2025@localhost:5432/go-labs-tst?sslmode=disable&search_path=billing" \
            up

      # Run integration tests
      - name: Run integration tests
        env:
          # Database connection for tests (using application user)
          DATABASE_URL: postgresql://billing_app_tst_user:billing_app_tst_2025@localhost:5432/go-labs-tst?sslmode=disable&search_path=billing
          DB_HOST: localhost
          DB_PORT: 5432
          DB_USER: billing_app_tst_user
          DB_PASSWORD: billing_app_tst_2025
          DB_NAME: go-labs-tst
          DB_SSLMODE: disable
          APP_ENV: test
        run: go test -v -race -coverprofile=coverage-integration.out ./tests/integration/...

      # Upload integration test coverage
      - name: Upload integration test coverage
        uses: actions/upload-artifact@v4
        with:
          name: coverage-integration
          path: coverage-integration.out

  # Job 3: Merge coverage reports and upload to Codecov
  coverage:
    name: Coverage Report
    runs-on: ubuntu-latest
    needs: [unit-tests-and-lint, integration-tests]
    if: always() && needs.unit-tests-and-lint.result == 'success'  # Run even if integration tests fail
    
    steps:
      # Checkout for codecov
      - uses: actions/checkout@v4

      # Download unit test coverage
      - name: Download unit test coverage
        uses: actions/download-artifact@v4
        with:
          name: coverage-unit

      # Download integration test coverage (if available)
      - name: Download integration test coverage
        uses: actions/download-artifact@v4
        with:
          name: coverage-integration
        continue-on-error: true  # Don't fail if integration tests didn't run

      # Merge coverage reports
      - name: Merge coverage reports
        run: |
          echo "mode: set" > coverage.out
          
          # Add unit test coverage
          if [ -f coverage-unit.out ]; then
            tail -n +2 coverage-unit.out >> coverage.out
            echo "Added unit test coverage"
          fi
          
          # Add integration test coverage if available
          if [ -f coverage-integration.out ]; then
            tail -n +2 coverage-integration.out >> coverage.out
            echo "Added integration test coverage"
          fi
          
          # Display coverage summary
          if command -v go &> /dev/null; then
            go tool cover -func=coverage.out || true
          fi

      # Upload to Codecov
      - name: Upload coverage to Codecov
        uses: codecov/codecov-action@v4
        with:
          file: ./coverage.out
          flags: unittests,integration
          name: billing-api
          fail_ci_if_error: false
          verbose: true

  # Job 4: Build Container (runs after integration tests pass)
  build-container:
    name: Build Container
    runs-on: ubuntu-latest
    needs: integration-tests  # Only build if integration tests pass
    permissions:
      contents: read
      packages: write
      
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
        
      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
          
      - name: Determine image tags
        id: tags
        run: |
          TAGS=""
          
          # Pull request
          if [[ "${{ github.event_name }}" == "pull_request" ]]; then
            TAGS="ghcr.io/gjaminon-go-labs/billing-api:pr-${{ github.event.pull_request.number }}"
            
          # Main branch
          elif [[ "${{ github.ref }}" == "refs/heads/main" ]]; then
            TAGS="ghcr.io/gjaminon-go-labs/billing-api:latest"
            
          # Feature/fix branches
          else
            BRANCH=${GITHUB_REF#refs/heads/}
            # Replace / with - in branch names
            SAFE_BRANCH=${BRANCH//\//-}
            TAGS="ghcr.io/gjaminon-go-labs/billing-api:${SAFE_BRANCH}"
          fi
          
          echo "tags=${TAGS}" >> $GITHUB_OUTPUT
          echo "Image will be tagged as: ${TAGS}"
          
      - name: Extract metadata
        id: meta
        run: |
          echo "commit=$(git rev-parse --short HEAD)" >> $GITHUB_OUTPUT
          echo "date=$(date -u +"%Y-%m-%dT%H:%M:%SZ")" >> $GITHUB_OUTPUT
          
      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          tags: ${{ steps.tags.outputs.tags }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          build-args: |
            VERSION=${{ github.sha }}
            BUILD_DATE=${{ steps.meta.outputs.date }}
            GIT_COMMIT=${{ steps.meta.outputs.commit }}
            
      - name: Comment on PR with image tag
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          script: |
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: 'üê≥ Container image built and pushed:\n```\nghcr.io/gjaminon-go-labs/billing-api:pr-${{ github.event.pull_request.number }}\n```\n\nPull with:\n```bash\ndocker pull ghcr.io/gjaminon-go-labs/billing-api:pr-${{ github.event.pull_request.number }}\n```'
            })

  # Job 5: Semantic Release (only on main branch)
  release:
    name: Semantic Release
    runs-on: ubuntu-latest
    needs: integration-tests  # Only after tests pass
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'  # Only on main branch push
    permissions:
      contents: write
      packages: write
      issues: write
      pull-requests: write
      
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Need full history for semantic-release
          
      - name: Setup Node.js (for semantic-release)
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          
      - name: Install semantic-release
        run: |
          npm install -g semantic-release @semantic-release/git @semantic-release/github @semantic-release/changelog
          
      - name: Check if release needed
        id: check_release
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Dry run to check if a release is needed
          npx semantic-release --dry-run --no-ci > semantic-output.txt 2>&1 || true
          
          # Check if a new version will be created
          if grep -q "The next release version is" semantic-output.txt; then
            VERSION=$(grep "The next release version is" semantic-output.txt | sed 's/.*The next release version is \(.*\)/\1/')
            echo "version=${VERSION}" >> $GITHUB_OUTPUT
            echo "new_release=true" >> $GITHUB_OUTPUT
            echo "üéâ New version will be: ${VERSION}"
          else
            echo "No release needed based on commits"
            echo "new_release=false" >> $GITHUB_OUTPUT
          fi
          
      - name: Create Release
        if: steps.check_release.outputs.new_release == 'true'
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          npx semantic-release --no-ci
          
      - name: Set up Docker Buildx
        if: steps.check_release.outputs.new_release == 'true'
        uses: docker/setup-buildx-action@v3
        
      - name: Log in to GitHub Container Registry
        if: steps.check_release.outputs.new_release == 'true'
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
          
      - name: Extract metadata
        if: steps.check_release.outputs.new_release == 'true'
        id: meta
        run: |
          echo "commit=$(git rev-parse --short HEAD)" >> $GITHUB_OUTPUT
          echo "date=$(date -u +"%Y-%m-%dT%H:%M:%SZ")" >> $GITHUB_OUTPUT
          
      - name: Build and push versioned images
        if: steps.check_release.outputs.new_release == 'true'
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          tags: |
            ghcr.io/gjaminon-go-labs/billing-api:${{ steps.check_release.outputs.version }}
            ghcr.io/gjaminon-go-labs/billing-api:latest
          cache-from: type=gha
          cache-to: type=gha,mode=max
          build-args: |
            VERSION=${{ steps.check_release.outputs.version }}
            BUILD_DATE=${{ steps.meta.outputs.date }}
            GIT_COMMIT=${{ steps.meta.outputs.commit }}

  # Job 6: Claude Code Review (runs only after all tests pass to save tokens)
  claude-review:
    name: Claude Code Review
    runs-on: ubuntu-latest
    needs: [unit-tests-and-lint, integration-tests]  # Only run after ALL tests pass
    if: github.event_name == 'pull_request'  # Only run on PRs
    permissions:
      contents: write
      pull-requests: write
      issues: write
      id-token: write
      actions: read  # Allow Claude to read CI results

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - name: Run Claude Code Review
        id: claude-review
        uses: anthropics/claude-code-action@beta
        continue-on-error: true  # Don't fail the CI if review fails
        with:
          claude_code_oauth_token: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}

          # Allow Claude to read CI results
          additional_permissions: |
            actions: read

          # Direct prompt for automated Go code review
          direct_prompt: |
            Please review this Go pull request focusing on:

            ## Code Quality
            - Go best practices and idiomatic code
            - Proper error handling patterns
            - Correct use of goroutines and channels (if applicable)
            - Memory management and potential leaks

            ## Architecture
            - Domain-Driven Design principles compliance
            - Repository pattern implementation
            - Clean Architecture layer separation
            - Dependency injection patterns

            ## Testing
            - Test coverage adequacy (minimum 70% for new code)
            - Table-driven test patterns
            - Unit vs integration test separation
            - Mock usage appropriateness

            ## Go-Specific Checks
            - Proper use of interfaces
            - Error wrapping with context
            - Struct field tags correctness
            - Concurrent code safety

            ## TDD Workflow
            - Verify tests were written first (Red-Green-Refactor)
            - Check for overengineering beyond requirements
            - Ensure minimal implementation approach

            ## Security
            - SQL injection prevention
            - Input validation
            - No hardcoded secrets
            - Proper authentication/authorization

            ## Performance
            - Database query optimization
            - N+1 query problems
            - Unnecessary allocations
            - Proper use of pointers vs values

            Review the CI test results and coverage report.
            Be constructive and educational in feedback.
            Highlight both issues and good practices.

          # Use sticky comments for cleaner PR experience
          use_sticky_comment: true

          # Allow Claude to run Go-specific commands for analysis
          allowed_tools: "Bash(go test ./...),Bash(go vet ./...),Bash(go mod tidy),Bash(go fmt ./...)"